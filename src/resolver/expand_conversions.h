#pragma once

#include <cassert>
#include <functional>
#include <utility>

#include "conversion.h"
#include "cost.h"
#include "env.h"
#include "interpretation.h"
#include "type_map.h"

#include "data/cast.h"
#include "data/list.h"
#include "data/mem.h"
#include "data/range.h"
#include "lists/eager_merge.h"

/// Inserts a new interpretation into `expanded` with type `ty` if there is no 
/// interpretation already there that is cheaper than c; the new interpretation will be  
/// generated by calling interpretation(), a zero-arg function
template<typename F>
void setOrUpdateInterpretation( TypeMap< const Interpretation* >& expanded, 
                                const Type* ty, const Cost& c, F interpretation ) {
    auto existing = expanded.get( ty );
    if ( ! existing ) {
        // Type doesn't exist in map
        expanded.insert( ty, interpretation() );
    } else if ( const Interpretation** j = existing->get() ) {
        // Pre-existing interpretation ...
        if ( c < (*j)->cost ) {
            /// ... with higher cost
            existing->set( ty, interpretation() );
        } else if ( c == (*j)->cost ) {
            // ... with equal cost
            existing->set( ty, Interpretation::merge_ambiguous( *j, interpretation() ) );
        }   // ... ignore pre-existing interpretation with lower cost
    } else {
        // No value for type exists in map
        existing->set( ty, interpretation() );
    }
}

/// If `i` is null or `c` is less than `i->cost`, replaces `i` by the new interpretation 
/// generated by calling `interpretation`. If `c` equals `i->cost` will generate an 
/// ambiguous interpretation.
template<typename F>
void setOrUpdateInterpretation( const Interpretation*& i, const Cost& c, 
                                F interpretation ) {
    if ( ! i || c < i->cost ) {
        // replace missing or higher cost interpretation
        i = interpretation();
    } else if ( c == i->cost ) {
        // make ambiguous interpretation if equal cost
        i = Interpretation::merge_ambiguous( i, interpretation() );
    }   // ignore existing interpretation with lower cost
}

/// Replaces `results` with the conversion-expanded version
void expandConversions( InterpretationList& results, ConversionGraph& conversions ) {
    // Unique expanded interpretation for each type
    TypeMap< const Interpretation* > expanded;

    for ( const Interpretation* i : results ) {
        auto ty = i->expr->type();

        setOrUpdateInterpretation( expanded, ty, i->cost, [i]() { return i; } );

#ifdef RP_USER_CONVS
        #error User conversion expansion not yet implemented
#else // ! RP_USER_CONVS
        auto tid = typeof( ty );
        if ( typeof<ConcType>() == tid || typeof<NamedType>() == tid ) {
            for ( const Conversion& conv : conversions.find_from( ty ) ) {
                const Type* to = conv.to->type;
                Cost toCost = i->cost + conv.cost;

                setOrUpdateInterpretation( expanded, to, toCost, 
                    [i,&conv,&toCost]() { 
                        return new Interpretation{ new CastExpr{ i->expr, &conv }, 
                                                   copy(toCost) }; } );
            }
        } else if ( typeof<TupleType>() == tid ) {
            const TupleType* tty = as<TupleType>(ty);

            // list of conversions with default "self" non-conversion in each queue
            using ConversionQueues 
                = std::vector< defaulted_range<Conversion, ConversionGraph::const_iterator> >;
            ConversionQueues convs;
            convs.reserve( tty->size() );
            Conversion no_conv;  // special marker for self-conversion
            for ( unsigned j = 0; j < tty->size(); ++j ) {
                convs.emplace_back( no_conv, conversions.find_from( tty->types()[j] ) );
            }

            struct conversion_cost {
                const Cost& operator() ( const Conversion& c ) { return c.cost; }
            };

            bool first = true;
            for_each_cost_combo<Conversion, Cost, conversion_cost>(
                convs, 
                [tty,i,&first,&expanded]( 
                        const ConversionQueues& qs, const Indices& inds, const Cost& c ) {
                    // skip self iteration (no conversions on any queue)
                    if ( first ) { first = false; return; }
                    
                    List<Type> tys;  ///< underlying tuple types 
                    tys.reserve( qs.size() );
                    for ( unsigned j = 0; j < qs.size(); ++j ) {
                        unsigned k = inds[j];
                        const Conversion& conv = qs[j][k];

                        tys.push_back( k == 0 ? tty->types()[j] : conv.to->type );
                    }

                    Cost toCost = i->cost + c;

                    setOrUpdateInterpretation( expanded, new TupleType{ tys }, toCost, 
                        [tty,i,&qs,&inds,&toCost]() -> Interpretation* {
                            List<TypedExpr> els;
                            els.reserve( qs.size() );
                            for ( unsigned j = 0; j < qs.size(); ++j ) {
                                unsigned k = inds[j];
                                const Conversion& conv = qs[j][k];

                                auto *el = new TupleElementExpr( i->expr, j );

                                if ( k == 0 ) {
                                    els.push_back( el );
                                } else {
                                    els.push_back( new CastExpr{ el, &conv } );
                                }
                            }

                            return new Interpretation{ 
                                new TupleExpr( move(els) ), copy(toCost) };
                        } );
                } );
        }
#endif
    }

    // replace results with expanded results
    results.clear();
    for (auto it = expanded.begin(); it != expanded.end(); ++it) {
        results.push_back( it.get() );
    }
}

/// Attempts to bind a typeclass r to the concrete type conc in the current environment, 
/// returning true and incrementing cost if successful
bool classBinds( ClassRef r, const Type* conc, Env*& env, Cost& cost ) {
    // test for match if class already has a representative.
    // TODO this is a restriction to exact polymorphic type binding, but loosening it 
    //      would be non-trivial; [ or maybe I just call convertTo here... ]
    if ( r->bound ) return *r->bound == *conc;
    // otherwise make concrete class the new typeclass representative, incrementing cost
    bindType( env, r, conc );
    ++cost.poly;
    return true;
}

/// Replaces expression with the best conversion to the given type, updating cost and env 
/// as needed. Returns nullptr for no such conversion; may update env and cost on such a 
/// failure result.
const TypedExpr* convertTo( const Type* ttype, const TypedExpr* expr,                
                            ConversionGraph& conversions, Env*& env, Cost& cost ) {
    const Type* etype = expr->type();
    auto eid = typeof( etype );
    auto tid = typeof( ttype );

    if ( eid == typeof<ConcType>() || eid == typeof<NamedType>() ) {
        if ( tid == typeof<ConcType>() || tid == typeof<NamedType>() ) {
            // check exact match
            if ( *etype == *ttype ) return expr;

            // check converted match
            if ( const Conversion* conv = conversions.find_between( etype, ttype ) ) {
                cost += conv->cost;
                return new CastExpr{ expr, conv };
            }

            // no matches
            return nullptr;
        } else if ( tid == typeof<PolyType>() ) {
            // test for match if target typeclass already has representative
            ClassRef tclass = getClass( env, as<PolyType>(ttype) );
            return classBinds( tclass, etype, env, cost ) ? expr : nullptr;
        } else if ( tid == typeof<VoidType>() ) {
            // one safe conversion to truncate concrete type to Void
            ++cost.safe;
            return new TruncateExpr{ expr, ttype };
        } else if ( tid == typeof<TupleType>() ) {
            // can't match tuples to non-tuple types
            return nullptr;
        } else assert(!"Unhandled target type");
    } else if ( eid == typeof<PolyType>() ) {
        ClassRef eclass = getClass( env, as<PolyType>(etype) );

        if ( tid == typeof<ConcType>() || tid == typeof<NamedType>() ) {
            return classBinds( eclass, ttype, env, cost ) ? expr : nullptr;
        } else if ( tid == typeof<PolyType>() ) {
            // attempt to merge two typeclasses
            if ( bindVar( env, eclass, as<PolyType>(ttype) ) ) {
                ++cost.poly;
                return expr;
            } else return nullptr;
        } else if ( tid == typeof<VoidType>() || tid == typeof<TupleType>() ) {
            // neither tuples nor void can bind to PolyType vars.
            // TODO introduce ttype vars for this
            return nullptr;
        } else assert(!"Unhandled target type");
    } else if ( eid == typeof<VoidType>() ) {
        // fail for non-void targets
        return ( tid == typeof<VoidType>() ) ? expr : nullptr;
    } else if ( eid == typeof<TupleType>() ) {
        const TupleType* etuple = as<TupleType>(etype);
        unsigned en = etuple->size(), tn = ttype->size();

        // fail for target of greater arity
        if ( tn > en ) return nullptr;

        // target of lesser arity has safe cost of the number of elements trimmed
        switch (tn) {
        case 0: {
            // truncate to void
            cost.safe += en;
            return new TruncateExpr{ expr, ttype };
        } case 1: {
            // truncate to first element
            const TypedExpr* el = convertTo( ttype, new TupleElementExpr{ expr, 0 },
                                             conversions, env, cost );
            if ( ! el ) return nullptr;
            cost.safe += en - 1;
            return el;
        } default: {
            // make tuple out of the appropriate prefix
            const TupleType* ttuple = as<TupleType>(ttype);

            List<TypedExpr> els;
            els.reserve( ttuple->size() );
            for ( unsigned j = 0; j < tn; ++j ) {
                const TypedExpr* el = convertTo( ttuple->types()[j],
                                                 new TupleElementExpr{ expr, j },
                                                 conversions, env, cost );
                if ( ! el ) return nullptr;
                els.push_back( el );
            }
            cost.safe += en - tn;
            return new TupleExpr{ move(els) };
        }}
    } else assert(!"Unhandled expression type");

    return nullptr; // unreachable
}

/// Replaces `results` with the best interpretation (possibly conversion-expanded) as 
/// `targetType`.
/// If `targetType` is polymorphic, may result in multiple best interpretations.
InterpretationList convertTo( const Type* targetType, InterpretationList&& results, 
                              ConversionGraph& conversions ) {
    // best interpretation as targetType, null for none such
    TypeMap<const Interpretation*> best;

    for ( const Interpretation* i : results ) {
        const Type* ty = i->expr->type();
    
        if ( *ty == *targetType ) {
            // set interpretation if type matches
            setOrUpdateInterpretation( best, ty, i->cost, [i]() { return i; } );
        } else {
            Cost cost = i->cost;
            Env* newEnv = Env::from( i->env );
            const TypedExpr* newExpr = 
                convertTo( targetType, i->expr, conversions, newEnv, cost );
            if ( newExpr ) {
                setOrUpdateInterpretation( best, newExpr->type(), cost, 
                    [newExpr,&cost,newEnv]() {
                        return new Interpretation{ newExpr, copy(cost), newEnv };
                    } );
            }
        }
    }

    InterpretationList bests;
    for ( const auto& b : best ) { bests.push_back( b.second ); }
    return bests;
}
