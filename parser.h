#pragma once

#include <iostream>

#include "canonical_type_map.h"
#include "data.h"
#include "expr.h"
#include "func_table.h"
#include "type.h"

/// Parses input according to the following format:
///
/// start := <function_decl>+ "%%\n" <resolv_expr>+
/// function_decl := (<type>" ")* <name>("-"<tag>)? (" "<type>)* "\n"
/// resolv_expr := <subexpr> "\n"
/// subexpr := <type> | <name> " (" (" "<subexpr>)* " )"
/// name := [a-z][a-z0-9]*
/// tag := <name>
/// type := "-"?[0-9]+
///
/// Semantically, types are given numeric identifiers, and also stand in for 
/// variables of that type; the conversion cost from x => y is |x-y|; this is 
/// a safe conversion if x < y, unsafe if x > y. 
///
/// Functions are named conversions from one list of types to another (as in 
/// C, the list of types before the function name are the return types, while 
/// the list after are the parameter types); multiple functions may be given  
/// the same name, these may be disambiguated to the user of this program by  
/// providing a tag name that is unique; if no tag is provided one will be  
/// autogenerated from the parameter types. Otherwise, both function names and 
/// tags are lowercase ASCII strings.
///
/// Expressions to be resolved are (possibly recursive) function invocations 
/// with the leaf nodes represented by type identifiers corresponding to 
/// variables. 
///
/// Returns true and sets funcs, exprs & types if appropriate, 
/// prints errors otherwise.
bool parse_input( std::istream& in, FuncTable& funcs, List<Expr>& exprs, 
                  CanonicalTypeMap& types );
