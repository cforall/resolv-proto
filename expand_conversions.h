#pragma once

#include <functional>
#include <utility>

#include "conversion.h"
#include "cost.h"
#include "eager_merge.h"
#include "interpretation.h"
#include "type_map.h"

/// Inserts a new interpretation into `expanded` with type `ty` if there is no interpretation 
/// already there that is cheaper than c; the new interpretation will be generated by calling 
/// interpretation(), a zero-arg function
template<typename F>
void setOrUpdateInterpretation( TypeMap< const Interpretation* >& expanded, const Type* ty,  
                                const Cost& c, F interpretation ) {
    auto existing = expanded.get( ty );
    if ( ! existing ) {
        // Type doesn't exist in map
        expanded.insert( ty, interpretation() );
    } else if ( const Interpretation** j = existing->get() ) {
        // Pre-existing interpretation ...
        if ( c < (*j)->cost ) {
            /// ... with higher cost
            existing->set( interpretation() );
        } else if ( c == (*j)->cost ) {
            // ... with equal cost
            existing->set( Interpretation::make_ambiguous( ty, c ) );
        }   // ... ignore pre-existing interpretation with lower cost
    } else {
        // No value for type exists in map
        existing->set( interpretation() );
    }
}

/// Replaces `results` with the conversion-expanded version
void expandConversions( InterpretationList& results, ConversionGraph& conversions ) {
    // Unique expanded interpretation for each type
    TypeMap< const Interpretation* > expanded;

    for ( const Interpretation* i : results ) {
        auto ty = i->expr->type();

        setOrUpdateInterpretation( expanded, ty, i->cost, [i]() { return i; } );

#ifdef RP_USER_CONVS
        #error User conversion expansion not yet implemented
#else // ! RP_USER_CONVS
        auto tid = typeof( ty );
        if ( typeof<ConcType>() == tid )  {
            for ( const Conversion& conv : conversions.find( ty ) ) {
                const Type* to = conv.to->type;
                Cost toCost = i->cost + conv.cost;

                setOrUpdateInterpretation( expanded, to, toCost, 
                    [i,&conv,&toCost]() { return new Interpretation{ new CastExpr{ i->expr, &conv }, 
                                                                    copy(toCost) }; } );
            }
        } else if ( typeof<TupleType>() == tid ) {
/*            std::vector< const std::vector<Conversion>& > convs;
            convs.reserve( ty->size() );
            Conversion self;  // special marker for self-conversion
            for ( unsigned i = 0; i < ty->size(); ++i ) {
                convs.push_back( conversions.find( ty ) );
                
                // NOTE we need "no conversion" to be included in the list of options at each position; however, 
                // it isn't included in the conversion map; this solution is simple, but does not maintain the  
                // sorting order of the conversion list, nor is it thread-safe
                convs.back().push_back( self );
            }

            auto merged_convs = eager_merge<Conversion, Cost, 
                                            []( Conversion& c ) { return c.cost; }, 
                                            std::vector<Conversion>&>(convs);

            for ( auto& conv : merged_convs ) {

            }
*/        }
#endif
    }

    // replace results with expanded results
    results.clear();
    for (auto it = expanded.begin(); it != expanded.end(); ++it) {
        results.push_back( it.get() );
    }
}
