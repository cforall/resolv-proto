#pragma once

#include <functional>
#include <utility>

#include "conversion.h"
#include "cost.h"
#include "interpretation.h"
#include "type_map.h"

/// Inserts a new interpretation into `expanded` with type `ty` if there is no interpretation already there
/// that is cheaper than c; the new interpretation will be generated by calling interpretation(), a zero-arg function
template<typename F>
void setOrUpdateInterpretation( TypeMap< const Interpretation* >& expanded, const Type* ty, const Cost& c, 
                                F interpretation ) {
    auto existing = expanded.get( ty );
    if ( ! existing ) {
        // Type doesn't exist in map
        expanded.insert( ty, interpretation() );
    } else if ( const Interpretation** j = existing->get() ) {
        // Pre-existing interpretation ...
        if ( c < (*j)->cost ) {
            /// ... with higher cost
            existing->set( interpretation() );
        } else if ( c == (*j)->cost ) {
            // ... with equal cost
            existing->set( Interpretation::make_ambiguous( ty, c ) );
        }   // ... ignore pre-existing interpretation with lower cost
    } else {
        // No value for type exists in map
        existing->set( interpretation() );
    }
}

/// Replaces `results` with the conversion-expanded version
void expandConversions( InterpretationList& results, ConversionGraph& conversions ) {
    // Unique expanded interpretation for each type
    TypeMap< const Interpretation* > expanded;

    for ( const Interpretation* i : results ) {
        auto ty = i->expr->type();

        setOrUpdateInterpretation( expanded, ty, i->cost, [i]() { return i; } );

#ifdef RP_USER_CONVS
        #error User conversion expansion not yet implemented
#else // ! RP_USER_CONVS
        for ( const Conversion& conv : conversions.find( ty ) ) {
            const Type* to = conv.to->type;
            Cost toCost = i->cost + conv.cost;

            setOrUpdateInterpretation( expanded, to, toCost, 
                [i,&conv,&toCost]() { return new Interpretation{ new CastExpr{ i->expr, &conv }, 
                                                                 copy(toCost) }; } );
        }
#endif
    }

    // replace results with expanded results
    results.clear();
    for (auto it = expanded.begin(); it != expanded.end(); ++it) {
        results.push_back( it.get() );
    }
}
