#pragma once

#include <functional>
#include <utility>

#include "conversion.h"
#include "cost.h"
#include "cow.h"
#include "data.h"
#include "eager_merge.h"
#include "environment.h"
#include "interpretation.h"
#include "type_map.h"

/// Inserts a new interpretation into `expanded` with type `ty` if there is no interpretation 
/// already there that is cheaper than c; the new interpretation will be generated by calling 
/// interpretation(), a zero-arg function
template<typename F>
void setOrUpdateInterpretation( TypeMap< const Interpretation* >& expanded, const Type* ty,  
                                const Cost& c, F interpretation ) {
    auto existing = expanded.get( ty );
    if ( ! existing ) {
        // Type doesn't exist in map
        expanded.insert( ty, interpretation() );
    } else if ( const Interpretation** j = existing->get() ) {
        // Pre-existing interpretation ...
        if ( c < (*j)->cost ) {
            /// ... with higher cost
            existing->set( interpretation() );
        } else if ( c == (*j)->cost ) {
            // ... with equal cost
            existing->set( Interpretation::merge_ambiguous( *j, interpretation() ) );
        }   // ... ignore pre-existing interpretation with lower cost
    } else {
        // No value for type exists in map
        existing->set( interpretation() );
    }
}

/// If `i` is null or `c` is less than `i->cost`, replaces `i` by the new interpretation generated by 
/// calling `interpretation`. If `c` equals `i->cost` will generate an ambiguous interpretation.
template<typename F>
void setOrUpdateInterpretation( const Interpretation*& i, const Cost& c, F interpretation ) {
    if ( ! i || c < i->cost ) {
        // replace missing or higher cost interpretation
        i = interpretation();
    } else if ( c == i->cost ) {
        // make ambiguous interpretation if equal cost
        i = Interpretation::merge_ambiguous( i, interpretation() );
    }   // ignore existing interpretation with lower cost
}

/// Replaces `results` with the conversion-expanded version
void expandConversions( InterpretationList& results, ConversionGraph& conversions ) {
    // Unique expanded interpretation for each type
    TypeMap< const Interpretation* > expanded;

    for ( const Interpretation* i : results ) {
        auto ty = i->expr->type();

        setOrUpdateInterpretation( expanded, ty, i->cost, [i]() { return i; } );

#ifdef RP_USER_CONVS
        #error User conversion expansion not yet implemented
#else // ! RP_USER_CONVS
        auto tid = typeof( ty );
        if ( typeof<ConcType>() == tid )  {
            for ( const Conversion& conv : conversions.find( ty ) ) {
                const Type* to = conv.to->type;
                Cost toCost = i->cost + conv.cost;

                setOrUpdateInterpretation( expanded, to, toCost, 
                    [i,&conv,&toCost]() { return new Interpretation{ new CastExpr{ i->expr, &conv }, 
                                                                    copy(toCost) }; } );
            }
        } else if ( typeof<TupleType>() == tid ) {
            const TupleType* tty = as<TupleType>(ty);

            /// list of conversions with default "self" non-conversion in each queue
            typedef std::vector< defaulted_vector< Conversion, std::vector<Conversion> > >
                    ConversionQueues;  
            ConversionQueues convs;
            convs.reserve( tty->size() );
            Conversion no_conv;  // special marker for self-conversion
            for ( unsigned j = 0; j < tty->size(); ++j ) {
                convs.emplace_back( no_conv, conversions.find( tty->types()[j] ) );
            }

            struct conversion_cost {
                const Cost& operator() ( const Conversion& c ) { return c.cost; }
            };

            bool first = true;
            for_each_cost_combo<Conversion, Cost, conversion_cost>(
                convs, 
                [tty,i,&first,&expanded]( 
                        const ConversionQueues& qs, const Indices& inds, const Cost& c ) {
                    // skip self iteration (no conversions on any queue)
                    if ( first ) { first = false; return; }
                    
                    List<Type> tys;  ///< underlying tuple types 
                    tys.reserve( qs.size() );
                    for ( unsigned j = 0; j < qs.size(); ++j ) {
                        unsigned k = inds[j];
                        const Conversion& conv = qs[j][k];

                        tys.push_back( k == 0 ? tty->types()[j] : conv.to->type );
                    }

                    Cost toCost = i->cost + c;

                    setOrUpdateInterpretation( expanded, new TupleType{ tys }, toCost, 
                        [tty,i,&qs,&inds,&toCost]() -> Interpretation* {
                            List<TypedExpr> els;
                            els.reserve( qs.size() );
                            for ( unsigned j = 0; j < qs.size(); ++j ) {
                                unsigned k = inds[j];
                                const Conversion& conv = qs[j][k];

                                auto *el = new TupleElementExpr( i->expr, j );

                                if ( k == 0 ) {
                                    els.push_back( el );
                                } else {
                                    els.push_back( new CastExpr{ el, &conv } );
                                }
                            }

                            return new Interpretation{ new TupleExpr( move(els) ), copy(toCost) };
                        } );
                } );
        }
#endif
    }

    // replace results with expanded results
    results.clear();
    for (auto it = expanded.begin(); it != expanded.end(); ++it) {
        results.push_back( it.get() );
    }
}

/// Replaces expression with the best conversion to the given type, updating cost and env as needed
const TypedExpr* convertTo( const Type* targetType, const TypedExpr* expr, 
                            ConversionGraph& conversions, cow_ptr<Environment>& env, Cost& cost ) {
    // substitute target according to environment TODO count poly-cost
    const Type* ntarget = replace( env, targetType );
    
    const Type* ty = expr->type();
    
    if ( *ty == *targetType ) {
        // original expression matches
        return expr;
    }

    auto tid = typeof( ty );

    // substitute expression type according to environment TODO count poly-cost
    if ( typeof<PolyType>() == tid ) {
        ty = replace( env, as<PolyType>(ty) );
        tid = typeof( ty );
    }

    if ( typeof<ConcType>() == tid )  {
        // scan conversion list for matching type
        for ( const Conversion& conv : conversions.find( ty ) ) {
            if ( *conv.to->type == *targetType ) {
                cost += conv.cost;
                return new CastExpr{ expr, &conv };
            }
        }
    } else if ( typeof<TupleType>() == tid ) {
        // fail for non-tuple target
        if ( typeof<TupleType>() != typeof( targetType ) ) return nullptr;

        const TupleType* tty = as<TupleType>(ty);
        const TupleType* ttarget = as<TupleType>(targetType);

        // fail for mismatch on target size
        if ( tty->size() != ttarget->size() ) return nullptr;
        
        // decompose into elements and recurse
        List<TypedExpr> els;
        els.reserve( tty->size() );
        cow_ptr<Environment> newEnv = env;
        Cost newCost = cost;
        for ( unsigned j = 0; j < tty->size(); ++j ) {
            const TypedExpr* el = convertTo( ttarget->types()[j], 
                                             new TupleElementExpr{ expr, j }, 
                                             newEnv, newCost );
            // fail on no element conversion
            if ( ! el ) return nullptr;

            els.push_back( el );
        }
        env = move(newEnv);
        cost = newCost;
        return new TupleExpr{ move(els) };
    } else if ( typeof<PolyType>() == tid ) {
        // we know here that ty is unbound, or it would have been replaced above
        ++cost.poly;
        if ( const PolyType* ptarget = as_safe<PolyType>(targetType) ) {
            bindClass( env, ptarget, as<PolyType>(ty) );
        } else {
            bind( env, as<PolyType>(ty), targetType );
        }
        return expr;
    }

    return nullptr;
}

/// Replaces `results` with the best interpretation (possibly conversion-expanded) as `targetType`
const Interpretation* convertTo( const Type* targetType, InterpretationList&& results, 
                                 ConversionGraph& conversions, cow_ptr<Environment>& env ) {
    // best interpretation as targetType, null for none such
    Interpretation* best = nullptr;

    // substitute target according to environment
    targetType = replace( env, targetType );

    for ( const Interpretation* i : results ) {
        const Type* ty = i->expr->type();
    
        if ( *ty == *targetType ) {
            // set interpretation if type matches
            setOrUpdateInterpretation( best, i->cost, [i]() { return i; } );
        } else {
            Cost cost = i->cost;
            const TypedExpr* newExpr = convertTo( targetType, i->expr, conversions, env, cost );
            if ( newExpr ) {
                setOrUpdateInterpretation( best, cost, [newExpr,&cost]() {
                    return new Interpretation{ newExpr, copy(cost) }
                } );
            }
        }
    }

    return best;
}
